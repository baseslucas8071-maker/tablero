<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Visor de Estado - TV</title>
<style>
  :root{
    --bg:#071027;
    --card:#08203a;
    --muted:#cfe8ff;
    --accent:#00a3ff;
    --header-h-1: 48px; /* altura primera fila encabezado */
    --header-h-2: 44px; /* altura segunda fila (TPN / FRACTURADO) */
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,Segoe UI,Arial,sans-serif}
  .wrap{padding:14px;box-sizing:border-box;display:flex;flex-direction:column;height:100%}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  header h1{margin:0;font-size:28px;letter-spacing:0.6px}
  header .meta{opacity:0.9;font-size:13px;color:var(--muted)}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{background:#0b61a8;border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.08)}
  .switch{display:flex;align-items:center;gap:8px;font-size:14px;color:var(--muted)}
  main{flex:1;margin-top:12px;display:flex;gap:18px;align-items:stretch}
  .board{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:12px;box-sizing:border-box;display:flex;flex-direction:column}
  /* table container with scroll and sticky headers working relative to this container */
  .table-container{
    flex:1;
    overflow:auto;
    border-radius:8px;
    padding:6px;
    background:transparent;
  }
  table{border-collapse:collapse;width:100%;min-width:1200px}
  th,td{border:1px solid rgba(255,255,255,0.06);padding:8px 10px;text-align:center;white-space:nowrap}
  thead th{background:transparent}
  /* sticky header rows inside .table-container */
  thead tr:first-child th{position:sticky;top:0;z-index:11;padding-top:12px;padding-bottom:12px;font-size:16px}
  thead tr:nth-child(2) th{position:sticky;top:calc(var(--header-h-1));z-index:12;padding:8px 10px;background:rgba(0,0,0,0.15);font-weight:800}
  tbody td{height:44px;background:transparent;color:#e6f7ff}
  tbody tr.alt td{background:rgba(255,255,255,0.01)}
  td.rowid{background:rgba(255,255,255,0.03);font-weight:800;color:#bfe8ff;position:sticky;left:0;z-index:13}
  /* sticky first column header cell */
  thead th:first-child{position:sticky;left:0;top:0;z-index:15;background:linear-gradient(90deg, rgba(8,8,8,0.6), rgba(8,8,8,0.4));}
  thead tr:nth-child(2) th:first-child{top:calc(var(--header-h-1));}
  /* pozo colors */
  .pozo-1{background:linear-gradient(90deg,#ffd83a,#ffd83a); color:#002;}
  .pozo-2{background:linear-gradient(90deg,#7ad39a,#5fbf87); color:#002;}
  .pozo-3{background:linear-gradient(90deg,#74b3ff,#4686ff); color:#002;}
  .pozo-4{background:linear-gradient(90deg,#ff7b7b,#ff4c4c); color:#002;}
  .pozo-5{background:linear-gradient(90deg,#dfe6ea,#cfd9de); color:#002;}
  .pozo-6{background:linear-gradient(90deg,#e6f7ff,#d2efff); color:#002;text-transform:uppercase}
  .changed { animation: highlight 1.6s ease; box-shadow: 0 6px 18px rgba(0,160,220,0.10) inset; }
  @keyframes highlight {
    0% { background: rgba(255,255,0,0.45); transform: translateY(-2px); }
    100% { background: none; transform: translateY(0); }
  }
  footer{display:flex;justify-content:space-between;align-items:center;margin-top:10px;font-size:13px;color:var(--muted)}
  .indicators{display:flex;gap:12px;align-items:center}
  .ind{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px;font-weight:700}
  /* scrollbar (optional) */
  .table-container::-webkit-scrollbar{height:10px;width:10px}
  .table-container::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.06);border-radius:6px}
  @media(max-width:900px){
    header h1{font-size:18px}
    th,td{padding:6px 6px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Visor de Estado — Pozos</h1>
        <div class="meta">Kiosk / TV • Actualiza automáticamente</div>
      </div>
      <div class="controls">
        <label class="switch"><input id="autoScroll" type="checkbox" checked /> Auto-scroll (últimas 9)</label>
        <button class="btn" id="btnRefresh">Forzar actualización</button>
        <button class="btn secondary" id="btnPause">Pausar</button>
      </div>
    </header>

    <main>
      <div class="board">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
          <div style="font-size:14px">Última actualización: <strong id="lastUpdate">-</strong></div>
          <div class="indicators">
            <div class="ind" id="totalCount">Total: 0</div>
            <div class="ind" id="alertCount">Alertas: 0</div>
          </div>
        </div>

        <div class="table-container" id="tableWrap" tabindex="0">
          <table id="mainTable" aria-label="Visor">
            <thead>
              <tr id="hdrTop">
                <th style="width:90px">#</th>
                <!-- pozo top headers (se generan) -->
              </tr>
              <tr id="hdrSub">
                <th>&nbsp;</th>
                <!-- subheaders TPN/FRACTURADO (se generan) -->
              </tr>
            </thead>
            <tbody id="tbody">
              <!-- filas #01..#60 (se generan una vez en init) -->
            </tbody>
          </table>
        </div>

        <footer>
          <div class="meta">Fuente: status.json (GitHub Pages)</div>
          <div class="meta">Actualiza cada <span id="refreshSec">15</span>s</div>
        </footer>
      </div>
    </main>
  </div>

<script>
/*
  Visor de estado completo
  - Mantiene filas fijas #01..#60 en DOM
  - Actualiza celdas y encabezados dinámicamente
  - Auto-scroll inteligente para mostrar últimas 9 filas con datos (sin reordenar)
*/

const JSON_URL = 'status.json'; // ruta al JSON (usar cache-bypass)
const REFRESH_SECONDS = 15;
const ROWS = 60;
const POZOS = 6;
const LAST_N = 9; // últimas filas con datos a mostrar al auto-scroll

// estado
let pozoNames = Array.from({length:POZOS}, (_,i)=>`POZO #${i+1}`);
let paused = false;
let prevMap = {};      // stringified previous row object por id
let latestDataMap = {}; // objeto actual por id

// UI refs
const tableWrap = document.getElementById('tableWrap');
const tbody = document.getElementById('tbody');
const hdrTop = document.getElementById('hdrTop');
const hdrSub = document.getElementById('hdrSub');
const autoScrollCheckbox = document.getElementById('autoScroll');

document.getElementById('refreshSec').innerText = REFRESH_SECONDS;
document.getElementById('btnRefresh').addEventListener('click', ()=> loadAndRender(true));
document.getElementById('btnPause').addEventListener('click', togglePause);

function togglePause(){
  paused = !paused;
  document.getElementById('btnPause').innerText = paused ? 'Reanudar' : 'Pausar';
}

// --- Inicialización: crear filas fijas y headers (solo estructura DOM) ---
function initStructure(){
  // crear headers top / sub (vacíos, se actualizan luego)
  for(let i=1;i<=POZOS;i++){
    // top header placeholder
    const th = document.createElement('th');
    th.className = `pozo-${i} pozoTop`;
    th.colSpan = 2;
    th.dataset.pozoIndex = i;
    th.innerText = `POZO #${i}`;
    hdrTop.appendChild(th);
    // subheaders
    const th1 = document.createElement('th');
    th1.className = 'pozoSub';
    th1.innerText = 'TPN';
    const th2 = document.createElement('th');
    th2.className = 'pozoSub';
    th2.innerText = 'FRACTURADO';
    hdrSub.appendChild(th1);
    hdrSub.appendChild(th2);
  }

  // crear 60 filas fijas (#01..#60)
  tbody.innerHTML = '';
  for(let i=1;i<=ROWS;i++){
    const id = '#'+String(i).padStart(2,'0');
    const tr = document.createElement('tr');
    tr.dataset.rowId = id;
    if(i%2===0) tr.classList.add('alt');

    // id cell (sticky)
    const tdId = document.createElement('td');
    tdId.className = 'rowid';
    tdId.innerText = id;
    tr.appendChild(tdId);

    // crear 2*POZOS td vacíos
    for(let p=1;p<=POZOS;p++){
      const td1 = document.createElement('td');
      td1.dataset.col = `Pozo${p}`;
      td1.innerText = '';
      const td2 = document.createElement('td');
      td2.dataset.col = `Estado${p}`;
      td2.innerText = '';
      tr.appendChild(td1);
      tr.appendChild(td2);
    }
    tbody.appendChild(tr);
  }
}

// --- Helpers ---
function itemsArrayToMap(items){
  const map = {};
  if(!Array.isArray(items)) return map;
  for(const it of items){
    const key = (it.fila||'').toString().trim();
    if(key) map[key] = it;
  }
  return map;
}

function tieneDatosVisibles(dataObj){
  if(!dataObj) return false;
  for(let i=1;i<=POZOS;i++){
    const p = dataObj['Pozo'+i];
    const e = dataObj['Estado'+i];
    if((p && String(p).trim()!=='') || (e && String(e).trim()!=='') ) return true;
  }
  return false;
}

function updateHeaderNames(headerObj){
  if(!headerObj) return false;
  const newNames = [];
  for(let i=1;i<=POZOS;i++){
    const p = headerObj['Pozo'+i] || `POZO #${i}`;
    const e = headerObj['Estado'+i] ? ' ' + headerObj['Estado'+i] : '';
    newNames.push((p + e).trim());
  }
  if(JSON.stringify(newNames) !== JSON.stringify(pozoNames)){
    pozoNames = newNames;
    // actualizar texto de th existentes
    const ths = hdrTop.querySelectorAll('th.pozoTop');
    ths.forEach((th, idx) => {
      if(newNames[idx]) th.innerText = newNames[idx];
    });
  }
}

// actualiza una fila en el DOM y devuelve lista de celdas que cambiaron
function updateRowDom(rowId, newObj){
  const tr = tbody.querySelector(`tr[data-row-id="${rowId}"]`);
  if(!tr) return [];
  const changedCells = [];
  for(let p=1;p<=POZOS;p++){
    const key1 = 'Pozo'+p;
    const key2 = 'Estado'+p;
    const td1 = tr.querySelector(`td[data-col="${key1}"]`);
    const td2 = tr.querySelector(`td[data-col="${key2}"]`);
    const newVal1 = (newObj && newObj[key1]) ? String(newObj[key1]) : '';
    const newVal2 = (newObj && newObj[key2]) ? String(newObj[key2]) : '';

    if(td1 && td1.innerText !== newVal1){
      td1.innerText = newVal1;
      changedCells.push(td1);
    }
    if(td2 && td2.innerText !== newVal2){
      td2.innerText = newVal2;
      changedCells.push(td2);
    }
  }
  return changedCells;
}

// resaltar fila (o celdas) que cambiaron
function highlightCells(cells){
  if(!cells || cells.length===0) return;
  // preferimos añadir la clase al TR para efecto visible
  const seenRows = new Set();
  cells.forEach(td=>{
    const tr = td.closest('tr');
    if(tr && !seenRows.has(tr)){
      seenRows.add(tr);
      tr.classList.add('changed');
      setTimeout(()=> tr.classList.remove('changed'), 1800);
    }
  });
}

// detectar si el usuario está en la parte inferior (con margen)
function isUserAtBottom(marginPx = 60){
  const c = tableWrap;
  return (c.scrollHeight - (c.scrollTop + c.clientHeight)) <= marginPx;
}

// compute lista ordenada de ids que tienen datos (ascendente por número)
function getAllIdsWithData(){
  const ids = [];
  for(let i=1;i<=ROWS;i++){
    const id = '#'+String(i).padStart(2,'0');
    if(tieneDatosVisibles(latestDataMap[id])) ids.push(id);
  }
  return ids;
}

// scroll para que la primera de las últimas N filas con datos quede visible (manteniendo orden)
function scrollToShowLastN(n){
  if(!autoScrollCheckbox.checked) return;
  const withData = getAllIdsWithData();
  if(withData.length===0) return;
  const lastN = withData.slice(-n);
  const firstToShow = lastN[0];
  const tr = tbody.querySelector(`tr[data-row-id="${firstToShow}"]`);
  if(!tr) return;
  // calcular desplazamiento relativo al contenedor
  const container = tableWrap;
  const headerHeight = hdrTop.offsetHeight + hdrSub.offsetHeight;
  // scrollTop target: position of tr relative to container + current scrollTop - headerHeight
  const trOffsetTop = tr.offsetTop;
  container.scrollTop = trOffsetTop - headerHeight - 8;
}

// actualizar contadores
function updateCounters(){
  const totalConDatos = getAllIdsWithData().length;
  let alertCount = 0;
  for(const id of Object.keys(latestDataMap)){
    for(let p=1;p<=POZOS;p++){
      const v = String(latestDataMap[id]['Estado'+p] || '').toUpperCase();
      if(v.includes('FRACT') || v.includes('ALERT') || v.includes('FAULT')) alertCount++;
    }
  }
  document.getElementById('totalCount').innerText = `Total: ${totalConDatos}`;
  document.getElementById('alertCount').innerText = `Alertas: ${alertCount}`;
}

// --- LOAD & APPLY JSON ---
let userScrolledManually = false;
let lastLoadTimestamp = 0;

// si el usuario manipula el scroll se considera "manual" y no forzamos auto-scroll
tableWrap.addEventListener('scroll', () => {
  // si el usuario scrollea y no está cerca del fondo, marcamos manual
  userScrolledManually = !isUserAtBottom(40);
});

// carga y aplica cambios
async function loadAndRender(force=false){
  if(paused && !force) return;
  try{
    const res = await fetch(JSON_URL + '?_=' + Date.now(), {cache:'no-store'});
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const json = await res.json();

    // update last update timestamp
    document.getElementById('lastUpdate').innerText = new Date(json.lastUpdate || Date.now()).toLocaleString();

    // if header row present (fila==""), update pozo names
    if(Array.isArray(json.items)){
      const headerRow = json.items.find(it => (it.fila||'').toString().trim()==='');
      if(headerRow) updateHeaderNames(headerRow);
    }

    // construir mapa
    const newMap = itemsArrayToMap(json.items || []);
    // comparar y actualizar por fila (no rehacer DOM entero)
    const changedCellsAll = [];
    for(let i=1;i<=ROWS;i++){
      const id = '#'+String(i).padStart(2,'0');
      const newObj = newMap[id] || {};
      const s = JSON.stringify(newObj);
      const prev = prevMap[id];

      // si prev undefined -> primer run: rellenar pero no resaltar
      if(prev === undefined){
        // inicializamos prevMap para evitar resaltar primer render
        prevMap[id] = s;
        latestDataMap[id] = newObj;
        // actualizar DOM valores
        updateRowDom(id, newObj);
        continue;
      }

      if(prev !== s){
        // hay cambio: actualizar DOM y resaltar
        const changedCells = updateRowDom(id, newObj);
        changedCellsAll.push(...changedCells);
        prevMap[id] = s;
        latestDataMap[id] = newObj;
      } else {
        // no cambia: mantener
        latestDataMap[id] = newObj;
      }
    }

    updateCounters();
    if(changedCellsAll.length) highlightCells(changedCellsAll);

    // auto-scroll: si autoScroll activo AND (force OR user estaba en bottom antes de actualizar)
    const wasAtBottom = isUserAtBottom(40);
    if(autoScrollCheckbox.checked && !paused && (force || wasAtBottom) ){
      // if user scrolled manually recently, respect that (unless force)
      if(force || !userScrolledManually){
        scrollToShowLastN(LAST_N);
      }
    }

    // if user had scrolled but now we're at bottom, reset manual flag
    if(isUserAtBottom(40)) userScrolledManually = false;

    lastLoadTimestamp = Date.now();
  } catch(err){
    console.error('Error cargando status.json:', err);
    document.getElementById('lastUpdate').innerHTML = `<span style="color:salmon">Error al cargar datos</span>`;
  }
}

// init
initStructure();
loadAndRender(true);
setInterval(()=> loadAndRender(false), REFRESH_SECONDS * 1000);
</script>
</body>
</html>
